# nstl  

## 简介  
nstl(not standard template library) 是一些常用数据结构与算法的集合。  
此library重点在于练习数据结构与算法，故不会完全按照c++stl方式组织代码。  
实现主要参照llvm中的stl，stlport，各种算法书籍以及博客分享等，在此对分享知识的人表示感谢！

## 已实现内容

### allocator
malloc与free的一层浅包装。

### iterator
基本的迭代器类型。

### vector
实现了基本的动态增长。增长因子为2。  
增长复杂度为O(N)。

#### 实现原理
分配线性存储空间，在末尾预留一定空间以避免频繁的空间分配，当某次添加元素内存不足时，重新分配2倍大的空间并将原始数组里所有元素迁移到新数组。

### stack
实现了基本的接口。

#### 实现原理
stack为容器适配器，以vector，deque，list等支持后端插入删除的容器实现真正操作。

#### TODO
使用不同的配置容器进行测试，benchmark。（当前只测试了适配vector）

### deque
实现了基本的前后端插入删除操作。

#### 实现原理
本库中由一个双端增长的devector实现中控，增长策略为某一端满就分配当前已有元素3倍的空间，并将旧元素移动到新空间中间并释放旧空间。  
deque由中控指向实际元素存储的数组。

##### 1
可以适配链表实现。 

##### 2 
仿照数组后端插入策略，为deque前后端都预留空间，分配新空间时为前后端都预留一定内存，就可以实现O(1)复杂度的双端操作。  
可以通过一定策略来改进空间利用率。  
策略1：当某一端空间满后，如另一端有空间，可以将当前已有数据移动到空间中部，无需进行新空间分配。  
策略2：可以利用循环数组的原理，在某一端满后，循环到空间另一侧，直至将空间使用完毕。  
libc++实现为策略1   

##### 3
为了减少移动等操作，通过一个deque<T*>作为中控，中控由以上方式实际实现，中控中每个指针指向一个固定大小的数组，当重新分配元素时改变中控，无需再次分配与移动实际的值。  

##### 特别注意
deque需要特别关注尾迭代器，因为通过中控将元素存储分成了多个段，所以通过将空间中最后一个元素的地址作为尾迭代器，这导致了固定一个元素的空间浪费。且在实现时特别注意要在初始化和clear等后也要保证中控中已经分配了一段内存，以便尾指针指向正确



